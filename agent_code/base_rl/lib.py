# -*- coding: utf-8 -*-
"""final_project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eYKPThSySRZDE2PHft1SEYIhs5UxupL3
"""
import random
from queue import Queue
from collections import deque
import numpy as np
import traceback
from sklearn.base import clone
from sklearn.utils.validation import check_is_fitted
from sklearn.multioutput import MultiOutputRegressor
from sklearn.linear_model import SGDRegressor
from sklearn.decomposition import IncrementalPCA

from .agent_setting import ACTIONS, NUMBER_OF_FEATURE

class CustomRegressor:
    def __init__(self, estimator, game_handler):
        # Create one regressor for each action separately.
        self.reg_model = [clone(estimator) for i in range(len(ACTIONS))]
        self.handle = game_handler

    def partial_fit(self, X, y):
        '''
        Fit each regressor individually on its set of data.

        Parameters:
        -----------
        X: list
            List of length len(ACTIONS), where each entry is a 2d array of
            shape=(n_samples, n_features) with feature data corresponding to the
            given regressor. While n_features must be the same for all arrays,
            n_samples can optionally be different in every array.
        y: list
            List of length len(ACTIONS), where each entry is an 1d array of
            shape=(n_samples,) corresponding to each regressor. Since each
            regressor is fully independent, n_samples need not be equal for
            every array in y, but must however match in size to the
            corresponding array in X mentioned above.

        Returns:
        --------
        Nothing.
        '''
        # For every action:
        for i in range(len(ACTIONS)):
            # Verify that we have data.
            if X[i] and y[i]:
                # Perform one epoch of SGD.
                self.reg_model[i].partial_fit(X[i], y[i])

    def predict(self, X, action_idx=None):
        '''
        Get predictions from all regressors on a set of samples. Can also return
        predictions by a single regressor.

        Parameters:
        -----------
        X: np.array shape=(n_samples, n_features)
            Feature matrix for the n_samples each with n_features as the number
            of dimensions.
        action_idx: int
            (Optional) if action_idx is specified, only get predictions from
            the chosen regressor.

        Returns:
        --------
        y_predict: np.array
            If action_idx is unspecified, return the predictions by all regressors
            for all samples in an array of shape=(n_samples, len(ACTIONS)). Else
            return predictions for the single specified regressor, in an array
            of shape=(n_samples,).
        '''
        X_re = X.reshape((-1, NUMBER_OF_FEATURE))
        if action_idx is None:
            y_predict = []
            for i in range(len(ACTIONS)):
                try:
                    y_predict.append(self.reg_model[i].predict(X_re))
                    #self.handle.logger.info(f"model {i}, predict {y_predict}")
                    #print("model ", i, y_predict)
                except Exception as e:
                    y_predict.append(np.zeros(len(X_re)))
                    #self.handle.logger.info(f"modelfaild {i}")
                    self.handle.logger.error(traceback.format_exc())
            return np.vstack(y_predict).T  # shape=(n_samples, len(ACTIONS))
        else:
            return self.reg_model[action_idx].predict(X)

def state_to_features(game_state: dict, coordinate_history: deque) -> np.array:
    """
        *This is not a required function, but an idea to structure your code.*

        Converts the game state to the input of your models, i.e.
        a feature vector.

        You can find out about the state of the game environment via game_state,
        which is a dictionary. Consult 'get_state_for_agent' in environment.py to see
        what it contains.

        :param game_state:  A dictionary describing the current game board.
        :return: np.array
        """
    # ---- INFORMATION EXTRACTION ----
    # Getting all useful information from the game state dictionary.
    if game_state is None:
        return None

    arena = game_state['field']
    _, score, bombs_left, (x, y) = game_state['self']
    bombs = [xy for (xy, t) in game_state['bombs']]
    bomb_xys = [xy for (xy, t) in bombs]
    others = [xy for (n, s, b, xy) in game_state['others']]
    coins = game_state['coins']
    # --------------------------------------------------------------------------
    # --------------------------------------------------------------------------
    ## ----basic situation----
    basic_info = []
    # whether or not there is a wall to the up, below, left, right
    basic_info.append(0 if arena[x, y - 1] != -1 else 1)
    basic_info.append(0 if arena[x, y + 1] != -1 else 1)
    basic_info.append(0 if arena[x - 1, y] != -1 else 1)
    basic_info.append(0 if arena[x + 1, y] != -1 else 1)
    # whether ot not there is a tile
    basic_info.append(0 if arena[x, y - 1] != 0 else 1)
    basic_info.append(0 if arena[x, y + 1] != 0 else 1)
    basic_info.append(0 if arena[x - 1, y] != 0 else 1)
    basic_info.append(0 if arena[x + 1, y] != 0 else 1)
    # whether or not there is a crate
    basic_info.append(0 if arena[x, y - 1] != 1 else 1)
    basic_info.append(0 if arena[x, y + 1] != 1 else 1)
    basic_info.append(0 if arena[x - 1, y] != 1 else 1)
    basic_info.append(0 if arena[x + 1, y] != 1 else 1)
    # whether or not a bomb is possible
    basic_info.append(bombs_left)

    ## ----bomb info----
    bomb_info = []
    # whether or not the agent is in the path of a bomb which is about to explode
    up_bomb = down_bomb = left_bomb = right_bomb = 0
    for xb, yb in bombs:
        if (xb == x):
            if yb - y < 0 and yb - y > -4:
                up_bomb = 1
            elif yb - y > 0 and yb - y < 4:
                down_bomb = 1
        if (yb == y):
            if xb - x < 0 and xb - y > -4:
                left_bomb = 1
            elif xb - x > 0 and xb - x < 4:
                right_bomb = 1

    bomb_info += [up_bomb, down_bomb, left_bomb, right_bomb]
    # whether or not the agent is in the path of a bomb which is about to explode
    danger_info = danger(x, y, arena, bombs)

    # Escape direction from current danger.
    move_info = safe_move(x, y, arena, bombs, others)

    # Go in the direction of other agents.
    others_info, others_reached = movement_towards_others(x, y, 5, arena, bombs, others)

    # Direction to collectable coins.
    coins_info = movement_towards_coins(x, y, coins, arena, bombs, others)

    # Direction towards the tile to destroy crates.
    crates_info, crates_reached = explosion_most_boxes(x, y, 10, arena, bombs, others)

    target_acquired = int((others_reached or (crates_reached and all(others_info == (0, 0))))
                          and bombs_left and not danger_info)
    current_position_info = check_current_position_action(x, y, arena, bombs)
    # coordinate_history
    loop_info = min(coordinate_history.count((x,y)), 5)

    features = np.concatenate((danger_info, target_acquired, move_info, others_info,coins_info, crates_info,
                               current_position_info, loop_info), axis=None)
    return features.reshape(1, -1)[0]


def check_position(x: int, y: int, arena: np.array, object: str) -> bool:
    if object == 'crate':
        return arena[x, y] == 1
    elif object == 'free':
        return arena[x, y] == 0
    elif object == 'wall':
        return arena[x, y] == -1



def march_forward(x, y, direction):
    if direction == 'LEFT':
        x -= 1
    elif direction == 'RIGHT':
        x += 1
    elif direction == 'UP':
        y -= 1
    elif direction == 'DOWN':
        y += 1
    return x, y


def check_sides(x: int, y: int, direction: str) -> (int, int, int, int):
    if direction == 'UP' or direction == 'DOWN':
        jx, jy, kx, ky = x + 1, y, x - 1, y
    elif direction == 'RIGHT' or direction == 'LEFT':
        jx, jy, kx, ky = x, y + 1, x, y - 1
    else:
        raise ValueError(f"Invalid direction {direction}")
    return jx, jy, kx, ky


def danger(x, y, arena, bombs):

    if not check_position(x, y, arena, 'wall'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        if bombs:
            for (bx, by) in bombs:
                if bx == x and by == y:
                    return True
                for direction in directions:
                    ix, iy = bx, by
                    ix, iy = march_forward(ix, iy, direction)
                    while (not check_position(ix, iy, arena, 'wall') and
                           abs(ix - bx) <= 3 and abs(iy - by) <= 3):
                        if ix == x and iy == y:
                            return True
                        ix, iy = march_forward(ix, iy, direction)
        return False
    raise ValueError("error")


def get_free_neighbours(x: int, y: int, arena: np.array, bombs: list, others: list) -> list:

    directions = [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y)]
    neighbours = []
    random.shuffle(directions)  # Randomize such that no direction is prioritized.
    for ix, iy in directions:
        if (check_position(ix, iy, arena, 'free') and
                not (ix, iy) in bombs and
                not (ix, iy) in others):
            neighbours.append((ix, iy))
    return neighbours


def safe_move(x: int, y: int, arena: np.array, bombs: list, others: list) -> np.array:

    escapable = False  # initialization
    if bombs:
        # Breadth-first search for the closest non-lethal position.
        q = Queue()  # Create a queue.
        visited = []  # List to keep track of visited positions.
        graph = {}  # Saving node-parent relationships.
        root = ((x, y), (None, None))  # ((x, y), (parent_x, parent_y))
        visited.append(root[0])  # Mark as visited.
        q.put(root)  # Put in queue.
        while not q.empty():
            (ix, iy), parent = q.get()
            graph[(ix, iy)] = parent
            if not danger(ix, iy, arena, bombs):
                escapable = True
                break
            neighbours = get_free_neighbours(ix, iy, arena, bombs, others)
            for neighbour in neighbours:
                if not neighbour in visited:
                    visited.append(neighbour)
                    q.put((neighbour, (ix, iy)))
        if escapable:
            # Traverse the graph backwards from the target node to the source node.
            s = []  # empty sequence
            node = (ix, iy)  # target node
            if graph[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    s.insert(0, node)  # Insert at the front of the sequence.
                    node = graph[node]  # Get the parent.
            # Assigning a direction towards the escape tile.
            if len(s) > 1:
                next_node = s[1]  # The very next node towards the escape tile.
                rel_pos = (next_node[0] - x, next_node[1] - y)

                return np.array(rel_pos)
    return np.zeros(2)

def check_current_position_action(x: int, y: int, arena: np.array,bombs):
    if not check_position(x, y, arena, 'wall'):
        crates = number_bombdestroyed(x, y, arena)
        s = 5
        if check_position(x, y, arena, 'free') and 0 < crates < 3 and escape_own_bomb(x, y, arena):
            s = 1
        elif check_position(x, y, arena, 'free') and 2 < crates < 6 and escape_own_bomb(x, y, arena):
            s = 2
        elif check_position(x, y, arena, 'free') and crates > 5 and escape_own_bomb(x, y, arena):
            s = 3
        elif check_position(x, y, arena, 'free') and not escape_own_bomb(x, y, arena):
            s = 4
        elif bombs:
            for (bx, by) in bombs:
                if bx == x and by == y:
                    s = 0
        else:
            s = 5
    return s

def escape_own_bomb(x: int, y: int, arena: np.array) -> bool:

    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        for direction in directions:
            ix, iy = x, y
            ix, iy = march_forward(ix, iy, direction)
            while check_position(ix, iy, arena, 'free'):
                if abs(x - ix) > 3 or abs(y - iy) > 3:
                    return True
                jx, jy, kx, ky = check_sides(ix, iy, direction)
                if (check_position(jx, jy, arena, 'free') or
                        check_position(kx, ky, arena, 'free')):
                    return True
                ix, iy = march_forward(ix, iy, direction)
        return False
    else:
        raise ValueError("error")


def number_bombdestroyed(x: int, y: int, arena: np.array) -> int:

    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        crates = 0
        for direction in directions:
            ix, iy = x, y
            ix, iy = march_forward(ix, iy, direction)
            while (not check_position(ix, iy, arena, 'wall') and
                   abs(x - ix) <= 3 and abs(y - iy) <= 3):
                if check_position(ix, iy, arena, 'crate'):
                    crates += 1
                ix, iy = march_forward(ix, iy, direction)
        return crates
    else:
        return -1


def explosion_most_boxes(x: int, y: int, n: int, arena: np.array, bombs: list, others: list):

    candidates = []
    q = Queue()
    visited, graph = [], {}
    root = ((x, y), 0, (None, None))
    visited.append(root[0])
    q.put(root)
    while not q.empty():
        (ix, iy), steps, parent = q.get()
        if steps > n:
            continue
        graph[(ix, iy)] = parent
        crates = number_bombdestroyed(ix, iy, arena)
        if crates > 0 and escape_own_bomb(ix, iy, arena):
            candidates.append((crates, steps, (ix, iy)))
        neighbours = get_free_neighbours(ix, iy, arena, bombs, others)
        for neighb in neighbours:
            if not neighb in visited:
                visited.append(neighb)
                q.put((neighb, steps + 1, (ix, iy)))
    if candidates:
        w_max = 0
        for crates, steps, (ix, iy) in candidates:
            w = crates / (4 + steps)
            if w > w_max:
                w_max = w
                cx, cy = ix, iy
        s = []
        node = (cx, cy)
        if graph[node] != (None, None) or node == (x, y):
            while node != (None, None):
                s.insert(0, node)
                node = graph[node]
        if len(s) > 1:
            nx, ny = s[1]
            if not danger(nx, ny, arena, bombs):
                rel_pos = np.array([nx - x, ny - y])
                return rel_pos, False
        elif len(s) == 1:
            return np.zeros(2), True

    return np.zeros(2), False


def movement_towards_coins(x: int, y: int, coins: list, arena: np.array, bombs: list, others: list) -> np.array:

    reachable = False
    if coins:
        q = Queue()
        visited = []
        graph = {}
        root = ((x, y), 0, (None, None))  #
        visited.append(root[0])
        q.put(root)
        while not q.empty():
            (ix, iy), steps, parent = q.get()
            graph[(ix, iy)] = parent
            if (ix, iy) in coins:
                reachable = True  # Found the closest reachable coin.
                cx, cy = ix, iy  # Save position.
                break  # Stop the search.
            neighbours = get_free_neighbours(ix, iy, arena, bombs, others)
            for neighb in neighbours:
                if not neighb in visited:
                    visited.append(neighb)
                    q.put((neighb, steps + 1, (ix, iy)))
        if reachable:
            s = []
            node = (cx, cy)
            if graph[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    s.insert(0, node)
                    node = graph[node]
            if len(s) > 1:
                nx, ny = s[1]
                if not danger(nx, ny, arena, bombs):
                    rel_pos = np.array([nx - x, ny - y])
                    return rel_pos
    return np.zeros(2)


def danger_to_others(x: int, y: int, arena: np.array, others: list) -> bool:

    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        lethal_for_others = False
        for direction in directions:
            ix, iy = x, y
            ix, iy = march_forward(ix, iy, direction)
            while (not check_position(ix, iy, arena, 'wall') and
                   abs(x - ix) <= 3 and abs(y - iy) <= 3):
                if (ix, iy) in others:
                    lethal_for_others = True
                    break
                ix, iy = march_forward(ix, iy, direction)
        return lethal_for_others
    else:
        raise ValueError("error.")


def movement_towards_others(x: int, y: int, n: int, arena: np.array, bombs: list, others: list) -> (np.array, bool):

    if others:
        reachable = False
        q = Queue()
        visited, graph = [], {}
        root = ((x, y), 0, (None, None))
        visited.append(root[0])
        q.put(root)
        while not q.empty():
            (ix, iy), steps, parent = q.get()
            graph[(ix, iy)] = parent
            if steps > n:
                continue
            if (danger_to_others(ix, iy, arena, others) and
                    escape_own_bomb(ix, iy, arena)):
                reachable = True
                cx, cy = ix, iy
                break

            neighbours = get_free_neighbours(ix, iy, arena, bombs, others)
            for neighb in neighbours:
                if not neighb in visited:
                    visited.append(neighb)
                    q.put((neighb, steps + 1, (ix, iy)))

        if reachable:
            s = []
            node = (cx, cy)
            if graph[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    s.insert(0, node)
                    node = graph[node]
            if len(s) > 1:
                nx, ny = s[1]
                if not danger(nx, ny, arena, bombs):
                    rel_pos = np.array([nx - x, ny - y])
                    return rel_pos, False
            elif len(s) == 1:
                return np.zeros(2), True
    return np.zeros(2), False


def get_valid_actions(game_state: dict, filter_level: str = 'basic'):

    aggressive_play = True  # Allow agent to drop bombs.

    # Gather information about the game state
    _, _, bombs_left, (x, y) = game_state['self']
    arena = game_state['field']
    coins = game_state['coins']
    bombs = [xy for (xy, t) in game_state['bombs']]
    others = [xy for (n, s, b, xy) in game_state['others']]
    bomb_map = game_state['explosion_map']

    # Check for valid actions.
    #            [    'UP',  'RIGHT',   'DOWN',   'LEFT', 'WAIT']
    directions = [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y), (x, y)]

    # Initialization.
    valid_actions = []
    mask = np.zeros(len(ACTIONS))
    disallow_bombing = False
    lethal_status = np.zeros(len(directions))

    # Check the filtering level.
    if filter_level == 'full':
        # Check lethal status in all directions.
        for i, (ix, iy) in enumerate(directions):
            if not check_position(ix, iy, arena, 'wall'):
                lethal_status[i] = int(danger(ix, iy, arena, bombs))
            else:
                lethal_status[i] = -1
        # Verify that there is at least one non-lethal tile in the surrounding.
        if not any(lethal_status == 0):
            # No non-lethal tile detected, we can only disallow waiting.
            lethal_status = np.zeros(len(directions))
            lethal_status[-1] = 1

        # Check escape status on the current tile.
        if not escape_own_bomb(x, y, arena):
            disallow_bombing = True

    elif filter_level == 'basic':
        # Could to other things here.
        pass
    else:
        raise ValueError(f"Invalid option filter_level={filter_level}.")

    # Movement:
    for i, d in enumerate(directions):
        if (arena[d] == 0 and  # Is a free tile
                bomb_map[d] < 1 and  # No ongoing explosion
                not d in others and  # Not occupied by other player
                not d in bombs and  # No bomb placed
                lethal_status[i] == 0):  # Is non-lethal.
            valid_actions.append(ACTIONS[i])  # Append the valid action.
            mask[i] = 1  # Binary mask

    # Bombing:
    if bombs_left and aggressive_play and not disallow_bombing:
        valid_actions.append(ACTIONS[-1])
        mask[-1] = 1

    mask = (mask == 1)  # Convert binary mask to boolean mask.
    valid_actions = np.array(valid_actions)  # Convert list to numpy array

    if len(valid_actions) == 0:
        # The list is empty, there are no valid actions. Return all actions as
        # to not break the code by returning an empty list.
        return np.ones(len(ACTIONS)) == 1, ACTIONS
    else:
        return mask, valid_actions

def check_direction(direction: np.array, self_action: str) -> bool:
    """
    Check if a takcen action was the appropriate one given a certain
    direction vector.

    Parameters:
    -----------
    direction: np.array shape=(2,)
        Binary direction vector indicating the optimal direction to take.

    Returns:
    --------
    is_correct_action: bool
        True if the action taken was the correct one given the direction vector.
    """
    return ((all(direction == (0, 1)) and self_action == 'DOWN') or
            (all(direction == (1, 0)) and self_action == 'RIGHT') or
            (all(direction == (0, -1)) and self_action == 'UP') or
            (all(direction == (-1, 0)) and self_action == 'LEFT'))