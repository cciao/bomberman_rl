# -*- coding: utf-8 -*-
"""final_project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eYKPThSySRZDE2PHft1SEYIhs5UxupL3
"""
import random
from queue import Queue
import numpy as np
import traceback
from sklearn.base import clone
from sklearn.utils.validation import check_is_fitted
from sklearn.multioutput import MultiOutputRegressor
from sklearn.linear_model import SGDRegressor
from sklearn.decomposition import IncrementalPCA
from collections import deque
from .agent_setting import ACTIONS, NUMBER_OF_FEATURE

class CustomRegressor:
    def __init__(self, estimator, game_handler):
        # Create one regressor for each action separately.
        self.reg_model = [clone(estimator) for i in range(len(ACTIONS))]
        self.handle = game_handler

    def partial_fit(self, X, y):
        '''
        Fit each regressor individually on its set of data.

        Parameters:
        -----------
        X: list
            List of length len(ACTIONS), where each entry is a 2d array of
            shape=(n_samples, n_features) with feature data corresponding to the
            given regressor. While n_features must be the same for all arrays,
            n_samples can optionally be different in every array.
        y: list
            List of length len(ACTIONS), where each entry is an 1d array of
            shape=(n_samples,) corresponding to each regressor. Since each
            regressor is fully independent, n_samples need not be equal for
            every array in y, but must however match in size to the
            corresponding array in X mentioned above.

        Returns:
        --------
        Nothing.
        '''
        # For every action:
        for i in range(len(ACTIONS)):
            # Verify that we have data.
            if X[i] and y[i]:
                # Perform one epoch of SGD.
                self.reg_model[i].partial_fit(X[i], y[i])

    def predict(self, X, action_idx=None):
        '''
        Get predictions from all regressors on a set of samples. Can also return
        predictions by a single regressor.

        Parameters:
        -----------
        X: np.array shape=(n_samples, n_features)
            Feature matrix for the n_samples each with n_features as the number
            of dimensions.
        action_idx: int
            (Optional) if action_idx is specified, only get predictions from
            the chosen regressor.

        Returns:
        --------
        y_predict: np.array
            If action_idx is unspecified, return the predictions by all regressors
            for all samples in an array of shape=(n_samples, len(ACTIONS)). Else
            return predictions for the single specified regressor, in an array
            of shape=(n_samples,).
        '''
        X_re = X.reshape((-1, NUMBER_OF_FEATURE))
        if action_idx is None:
            y_predict = []
            for i in range(len(ACTIONS)):
                try:
                    y_predict.append(self.reg_model[i].predict(X_re))
                    #self.handle.logger.info(f"model {i}, predict {y_predict}")
                    #print("model ", i, y_predict)
                except Exception as e:
                    y_predict.append(np.zeros(len(X_re)))
                    #self.handle.logger.info(f"modelfaild {i}")
                    self.handle.logger.error(traceback.format_exc())
            return np.vstack(y_predict).T  # shape=(n_samples, len(ACTIONS))
        else:
            return self.reg_model[action_idx].predict(X)

def state_to_features(game_state: dict, coordinate_history: deque) -> np.array:
    """
        *This is not a required function, but an idea to structure your code.*

        Converts the game state to the input of your models, i.e.
        a feature vector.

        You can find out about the state of the game environment via game_state,
        which is a dictionary. Consult 'get_state_for_agent' in environment.py to see
        what it contains.

        :param game_state:  A dictionary describing the current game board.
        :return: np.array
        """
    # ---- INFORMATION EXTRACTION ----
    # Getting all useful information from the game state dictionary.
    if game_state is None:
        return None

    arena = game_state['field']
    _, score, bombs_left, (x, y) = game_state['self']
    bombs = [xy for (xy, t) in game_state['bombs']]
    bomb_xys = [xy for (xy, t) in bombs]
    others = [xy for (n, s, b, xy) in game_state['others']]
    coins = game_state['coins']

    # --------------------------------------------------------------------------

    danger_info = danger(x, y, arena, bombs)

    # Escape direction from current danger.
    move_info = safe_move(x, y, arena, bombs, others)

    # Go in the direction of other agents.
    others_info, others_reached = movement_towards_others(x, y, 5, arena, bombs, others)

    # Direction to collectable coins.
    coins_info = movement_towards_coins(x, y, coins, arena, bombs, others)

    # Direction towards the tile to destroy crates.
    crates_info, crates_reached = explosion_most_boxes(x, y, 10, arena, bombs, others)

    target_acquired = int((others_reached or (crates_reached and all(others_info == (0, 0))))
                          and bombs_left and not danger_info)
    current_position_info = check_current_position_action(x, y, arena, bombs)
    # coordinate_history
    loop_info = min(coordinate_history.count((x, y)), 6)

    # 12 dimensional feature.
    features = np.concatenate(
        (danger_info, target_acquired, move_info, others_info, coins_info, crates_info, current_position_info, loop_info),
        axis=None)
    return features.reshape(1, -1)[0]



def danger(x, y, arena, bombs):
    # Check whether the current position is dangerous.
    if not check_position(x, y, arena, 'wall'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        if bombs: # If there is a bomb.
            for (bx, by) in bombs: # The bomb is in its current position.
                if bx == x and by == y:
                    return True
                for direction in directions:
                    xx, yy = bx, by
                    xx, yy = march_forward(xx, yy, direction)
                    while (not check_position(xx, yy, arena, 'wall') and
                           abs(xx - bx) <= 3 and abs(yy - by) <= 3):
                        if xx == x and yy == y:
                            return True
                        xx, yy = march_forward(xx, yy, direction)
        return False
    raise ValueError("Error")


def safe_move(x, y, arena, bombs, others):
    # Check whether agent can escape the danger
    escapable = False
    if bombs:
        g = {}
        q = Queue()
        ergodic = []
        root_node = ((x, y), (None, None))
        ergodic.append(root_node[0])
        q.put(root_node)
        while not q.empty():
            (ix, iy), parent = q.get()
            g[(ix, iy)] = parent
            if not danger(ix, iy, arena, bombs):
                escapable = True
                break
            neighbours = get_surrounding_feasible_position(ix, iy, arena, bombs, others)
            for neighbour in neighbours:
                if not neighbour in ergodic:
                    ergodic.append(neighbour)
                    q.put((neighbour, (ix, iy)))
        if escapable:
            r = []
            node = (ix, iy)  # target node
            if g[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    r.insert(0, node)
                    node = g[node]
            if len(r) > 1:
                next_node = r[1]
                target_direction = (next_node[0] - x, next_node[1] - y)
                return np.array(target_direction)
    return np.zeros(2)


def check_current_position_action(x, y, arena, bombs):
    # Judge the number of crates destroyed.
    if not check_position(x, y, arena, 'wall'):
        crates = number_bombdestroyed(x, y, arena)
        s = 0
        if check_position(x, y, arena, 'free') and 0 < crates < 3 and escape_own_bomb(x, y, arena):
            s = 1
        elif check_position(x, y, arena, 'free') and 2 < crates < 6 and escape_own_bomb(x, y, arena):
            s = 2
        elif check_position(x, y, arena, 'free') and crates > 5 and escape_own_bomb(x, y, arena):
            s = 3
    return s


def escape_own_bomb(x, y, arena):
    # escape our own bomb.
    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        for direction in directions:
            xx, yy = x, y
            xx, yy = march_forward(xx, yy, direction)
            while check_position(xx, yy, arena, 'free'):
                if abs(x - xx) > 3 or abs(y - yy) > 3:
                    return True
                jx, jy, kx, ky = position_both_sides(xx, yy, direction)
                if (check_position(jx, jy, arena, 'free') or
                        check_position(kx, ky, arena, 'free')):
                    return True
                xx, yy = march_forward(xx, yy, direction)
        return False
    else:
        raise ValueError("error")


def number_bombdestroyed(x, y, arena):
    # Number of crates destroyed
    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        crates = 0
        for direction in directions:
            ix, iy = x, y
            ix, iy = march_forward(ix, iy, direction)
            while (not check_position(ix, iy, arena, 'wall') and
                   abs(x - ix) <= 3 and abs(y - iy) <= 3):
                if check_position(ix, iy, arena, 'crate'):
                    crates += 1
                ix, iy = march_forward(ix, iy, direction)
        return crates
    else:
        return -1


def explosion_most_boxes(x, y, n, arena, bombs, others):
    # Go to the direction with the largest number of crates.
    ergodic, g = [], {}
    c = []
    q = Queue()
    root_node = ((x, y), 0, (None, None))
    ergodic.append(root_node[0])
    q.put(root_node)
    while not q.empty():
        (ix, iy), steps, parent = q.get()
        if steps > n:
            continue
        g[(ix, iy)] = parent
        crates = number_bombdestroyed(ix, iy, arena)
        if crates > 0 and escape_own_bomb(ix, iy, arena):
            c.append((crates, steps, (ix, iy)))
        neighbours = get_surrounding_feasible_position(ix, iy, arena, bombs, others)
        for neighb in neighbours:
            if not neighb in ergodic:
                ergodic.append(neighb)
                q.put((neighb, steps + 1, (ix, iy)))
    if c:
        value_max = 0
        for crates, steps, (ix, iy) in c:
            value = crates / (4 + steps)
            if value > value_max:
                value_max = value
                cx, cy = ix, iy
        r = []
        node = (cx, cy)
        if g[node] != (None, None) or node == (x, y):
            while node != (None, None):
                r.insert(0, node)
                node = g[node]
        if len(r) > 1:
            nx, ny = r[1]
            if not danger(nx, ny, arena, bombs):
                target_direction = np.array([nx - x, ny - y])
                return target_direction, False
        elif len(r) == 1:
            return np.zeros(2), True

    return np.zeros(2), False


def movement_towards_coins(x, y, coins, arena, bombs, others):
    # Direction to coin.
    reachable = False
    if coins:
        ergodic = []
        g = {}
        q = Queue()
        root_node = ((x, y), 0, (None, None))
        ergodic.append(root_node[0])
        q.put(root_node)
        while not q.empty():
            (ix, iy), steps, parent = q.get()
            g[(ix, iy)] = parent
            if (ix, iy) in coins:
                reachable = True
                cx, cy = ix, iy
                break
            neighbours = get_surrounding_feasible_position(ix, iy, arena, bombs, others)
            for neighb in neighbours:
                if not neighb in ergodic:
                    ergodic.append(neighb)
                    q.put((neighb, steps + 1, (ix, iy)))
        if reachable:
            r = []
            node = (cx, cy)
            if g[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    r.insert(0, node)
                    node = g[node]
            if len(r) > 1:
                nx, ny = r[1]
                if not danger(nx, ny, arena, bombs):
                    target_direction = np.array([nx - x, ny - y])
                    return target_direction
    return np.zeros(2)


def danger_to_others(x, y, arena, others):
    # Is it dangerous to other players.
    if check_position(x, y, arena, 'free'):
        directions = ['UP', 'RIGHT', 'DOWN', 'LEFT']
        danger_to_others = False
        for direction in directions:
            ix, iy = x, y
            ix, iy = march_forward(ix, iy, direction)
            while (not check_position(ix, iy, arena, 'wall') and abs(x - ix) <= 3 and abs(y - iy) <= 3):
                if (ix, iy) in others:
                    danger_to_others = True
                    break
                ix, iy = march_forward(ix, iy, direction)
        return danger_to_others
    else:
        raise ValueError("error.")


def movement_towards_others(x, y, n, arena, bombs, others):
    # Go in the direction of other players.
    if others:
        reachable = False
        q = Queue()
        ergodic, g = [], {}
        root_node = ((x, y), 0, (None, None))
        ergodic.append(root_node[0])
        q.put(root_node)
        while not q.empty():
            (ix, iy), steps, parent = q.get()
            g[(ix, iy)] = parent
            if steps > n:
                continue
            if (danger_to_others(ix, iy, arena, others) and escape_own_bomb(ix, iy, arena)):
                reachable = True
                cx, cy = ix, iy
                break
            neighbours = get_surrounding_feasible_position(ix, iy, arena, bombs, others)
            for neighb in neighbours:
                if not neighb in ergodic:
                    ergodic.append(neighb)
                    q.put((neighb, steps + 1, (ix, iy)))

        if reachable:
            r = []
            node = (cx, cy)
            if g[node] != (None, None) or node == (x, y):
                while node != (None, None):
                    r.insert(0, node)
                    node = g[node]
            if len(r) > 1:
                nx, ny = r[1]
                if not danger(nx, ny, arena, bombs):
                    target_direction = np.array([nx - x, ny - y])
                    return target_direction, False
            elif len(r) == 1:
                return np.zeros(2), True
    return np.zeros(2), False


def get_valid_actions(game_state):

    aggressive_play = True  # Allow agent to drop bombs.

    # Gather information about the game state
    _, _, bombs_left, (x, y) = game_state['self']
    arena = game_state['field']
    coins = game_state['coins']
    bombs = [xy for (xy, t) in game_state['bombs']]
    others = [xy for (n, s, b, xy) in game_state['others']]
    bomb_map = game_state['explosion_map']

    # Check for valid actions.
    #  'UP', 'RIGHT', 'DOWN', 'LEFT', 'WAIT'
    directions = [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y), (x, y)]

    # Initialization.
    valid_actions = []
    mask = np.zeros(len(ACTIONS))
    prohibit_bombing = False
    danger_status = np.zeros(len(directions))


    # Check danger status in all directions.
    for i, (ix, iy) in enumerate(directions):
        if not check_position(ix, iy, arena, 'wall'):
            danger_status[i] = int(danger(ix, iy, arena, bombs))
        else:
            danger_status[i] = -1
    # Verify that there is at least one non-danger tile in the surrounding.
    if not any(danger_status == 0):
        # No non-danger tile detected, we can only prohibit waiting.
        danger_status = np.zeros(len(directions))
        danger_status[-1] = 1

    # Check escape status on the current tile.
    if not escape_own_bomb(x, y, arena):
        prohibit_bombing = True


    for i, d in enumerate(directions):
        if (arena[d] == 0 and
                bomb_map[d] < 1 and
                not d in others and
                not d in bombs and
                danger_status[i] == 0):
            valid_actions.append(ACTIONS[i])
            mask[i] = 1

    if bombs_left and aggressive_play and not prohibit_bombing:
        valid_actions.append(ACTIONS[-1])
        mask[-1] = 1
    mask = (mask == 1)
    valid_actions = np.array(valid_actions)

    if len(valid_actions) == 0:
        return np.ones(len(ACTIONS)) == 1, ACTIONS
    else:
        return mask, valid_actions


def get_surrounding_feasible_position(x, y, arena, bombs, others):
    # Get around where agent can travel
    surround = []
    directions = [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y)]
    random.shuffle(directions)
    for xx, yy in directions:
        # There are no bombs around, no other agents, and there is a feasible entry position.
        if not (xx, yy) in bombs and (check_position(xx, yy, arena, 'free') and not (xx, yy) in others):
            surround.append((xx, yy))
    return surround


def check_direction(direction, self_action):
    # Check whether the action performed is appropriate when a specific direction vector is given.
    return ((all(direction == (0, 1)) and self_action == 'DOWN') or
            (all(direction == (1, 0)) and self_action == 'RIGHT') or
            (all(direction == (0, -1)) and self_action == 'UP') or
            (all(direction == (-1, 0)) and self_action == 'LEFT'))


def check_position(x, y, arena, object):
    # Check whether the current position is of object type.
    if object == 'crate':
        return arena[x, y] == 1
    elif object == 'free':
        return arena[x, y] == 0
    elif object == 'wall':
        return arena[x, y] == -1


def march_forward(x, y, direction):
    # Forward in direction.
    if direction == 'LEFT':
        x -= 1
    elif direction == 'RIGHT':
        x += 1
    elif direction == 'UP':
        y -= 1
    elif direction == 'DOWN':
        y += 1
    return x, y


def position_both_sides(x, y, direction):
    # Get the position on both sides.
    if direction == 'UP' or direction == 'DOWN':
        jx, jy, kx, ky = x + 1, y, x - 1, y
    elif direction == 'RIGHT' or direction == 'LEFT':
        jx, jy, kx, ky = x, y + 1, x, y - 1
    else:
        raise ValueError("error")
    return jx, jy, kx, ky